<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multiplayer Chess Game</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Crimson+Text&display=swap" rel="stylesheet">
<style>
/* Reset and Base Styles */
* { margin:0; padding:0; box-sizing:border-box; }
:root {
    --wood-light:#d4a574; --wood-dark:#8b4513; --wood-grain:linear-gradient(90deg,#d4a574 0%,#c19a6b 25%,#a0845c 50%,#8b4513 75%,#a0845c 100%);
    --glass-white:rgba(240,240,240,0.9); --glass-black:rgba(40,40,40,0.85); --gold-accent:#d4af37;
    --shadow-light:rgba(0,0,0,0.2); --shadow-dark:rgba(0,0,0,0.6);
}
body { font-family:'Crimson Text', serif; background:linear-gradient(135deg,#2c1810 0%,#3d2817 50%,#2c1810 100%); min-height:100vh; color:#f4f4f4; }
.game-container { max-width:1400px; margin:0 auto; padding:20px; }
/* Header Styles */
.game-header { text-align:center; margin-bottom:30px; padding:20px; background:rgba(212,175,55,0.1); border-radius:15px; backdrop-filter:blur(10px);}
.game-title { font-family:'Cinzel', serif; font-size:3rem; font-weight:700; color:var(--gold-accent); text-shadow:2px 2px 4px rgba(0,0,0,0.5); margin-bottom:20px;}
.game-controls { display:flex; justify-content:center; gap:15px; flex-wrap:wrap;}
.control-btn { background:linear-gradient(145deg,var(--gold-accent),#b8941f); border:none; color:#2c1810; padding:12px 24px; font-size:1rem; font-weight:600; border-radius:8px; cursor:pointer; transition:all 0.3s ease; box-shadow:0 4px 8px rgba(0,0,0,0.3);}
.control-btn:hover { transform:translateY(-2px); box-shadow:0 6px 12px rgba(0,0,0,0.4); background:linear-gradient(145deg,#e6c547,var(--gold-accent));}
.control-btn.primary { background:linear-gradient(145deg,#4CAF50,#45a049); color:white;}
.control-btn.primary:hover { background:linear-gradient(145deg,#5CBF60,#4CAF50);}
/* Main Game Layout */
.game-main { display:grid; grid-template-columns:1fr auto; gap:30px; align-items:start; }
.game-info { background:rgba(212,165,116,0.1); border-radius:15px; padding:25px; backdrop-filter:blur(10px); border:1px solid rgba(212,175,55,0.3); }
.player-info { display:flex; flex-direction:column; gap:20px; }
.player { display:flex; align-items:center; gap:15px; padding:15px; background:rgba(255,255,255,0.05); border-radius:10px; border:1px solid rgba(212,175,55,0.2);}
.player-avatar { width:40px; height:40px; border-radius:50%; background:linear-gradient(145deg,var(--glass-white), rgba(200,200,200,0.8)); box-shadow:0 2px 8px var(--shadow-light);}
.black-player .player-avatar { background:linear-gradient(145deg,var(--glass-black), rgba(60,60,60,0.8));}
.player-name { font-size:1.1rem; font-weight:600; color:var(--gold-accent);}
.game-status { text-align:center; padding:20px; background:rgba(0,0,0,0.2); border-radius:10px;}
.status-text { font-size:1.2rem; font-weight:600; color:var(--gold-accent); margin-bottom:15px; }
.move-history { max-height:200px; overflow-y:auto; font-size:0.9rem; text-align:left; color:#ccc; }
/* Chess Board Styles */
.chess-board-container { position:relative; display:inline-block; }
.chess-board { display:grid; grid-template-columns:repeat(8,80px); grid-template-rows:repeat(8,80px); border:8px solid var(--wood-dark); border-radius:10px; background:var(--wood-grain); box-shadow:0 10px 30px rgba(0,0,0,0.6), inset 0 0 10px rgba(0,0,0,0.3); position:relative; }
.square { display:flex; align-items:center; justify-content:center; position:relative; cursor:pointer; transition:all 0.3s ease;}
.square.light { background:radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1), transparent 50%), linear-gradient(45deg,#f4e4bc,#e8d5a6);}
.square.dark { background:radial-gradient(circle at 30% 30%, rgba(255,255,255,0.05), transparent 50%), linear-gradient(45deg,#8b4513,#6d3410);}
.square.selected { background:radial-gradient(circle, rgba(212,175,55,0.6), transparent), var(--wood-grain); box-shadow: inset 0 0 10px var(--gold-accent);}
.square.valid-move { position:relative; }
.square.valid-move::before { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:20px; height:20px; background:var(--gold-accent); border-radius:50%; opacity:0.7; }
.square.valid-move.occupied::before { width:70px; height:70px; background:transparent; border:3px solid var(--gold-accent); border-radius:50%; }
/* Chess Pieces */
.piece { font-size:48px; text-shadow:2px 2px 4px rgba(0,0,0,0.8),0 0 10px rgba(255,255,255,0.3); cursor:pointer; transition:all 0.3s ease; filter:drop-shadow(0 4px 8px rgba(0,0,0,0.5)); position:relative;}
.piece.white { color:var(--glass-white); filter:drop-shadow(0 4px 8px rgba(0,0,0,0.6)) drop-shadow(0 0 10px rgba(255,255,255,0.4)); }
.piece.black { color:var(--glass-black); filter:drop-shadow(0 4px 8px rgba(0,0,0,0.8)) drop-shadow(0 0 5px rgba(0,0,0,0.3)); }
.piece:hover { transform:scale(1.1); filter:drop-shadow(0 6px 12px rgba(0,0,0,0.7)) drop-shadow(0 0 15px rgba(212,175,55,0.5)); }
.piece.dragging { z-index:1000; transform:scale(1.2); pointer-events:none; }
/* Modals */
.modal { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%) scale(0.9); background:rgba(20,20,20,0.95); padding:30px; border-radius:15px; box-shadow:0 10px 40px rgba(0,0,0,0.7); z-index:1000; display:flex; flex-direction:column; gap:20px; color:#fff;}
.modal h2 { font-size:1.5rem; text-align:center; color:var(--gold-accent);}
.modal p { font-size:1rem; text-align:center;}
.modal input { width:100%; padding:10px; border-radius:8px; border:none; font-size:1rem; text-align:center;}
.modal button { padding:10px 20px; border:none; border-radius:8px; font-weight:600; cursor:pointer;}
.modal .hidden { display:none; }
.victory-celebration { animation: glow 1.5s infinite alternate;}
@keyframes glow { 0% { text-shadow:0 0 10px var(--gold-accent);} 100% { text-shadow:0 0 30px #fff;} }
</style>
</head>
<body>
<div class="game-container">
    <header class="game-header">
        <h1 class="game-title">Multiplayer Chess</h1>
        <div class="game-controls">
            <button id="newGameBtn" class="control-btn primary">New Game</button>
            <button id="shareGameBtn" class="control-btn">Share Game</button>
            <button id="copyLinkBtn" class="control-btn">Copy Link</button>
        </div>
    </header>
    <main class="game-main">
        <div class="game-info">
            <div class="player-info">
                <div class="player white-player">
                    <div class="player-avatar"></div>
                    <div class="player-name">White</div>
                </div>
                <div class="player black-player">
                    <div class="player-avatar"></div>
                    <div class="player-name">Black</div>
                </div>
            </div>
            <div class="game-status">
                <div id="gameStatus" class="status-text">White to move</div>
                <div id="moveHistory" class="move-history"></div>
            </div>
        </div>
        <div class="chess-board-container">
            <div id="chessBoard" class="chess-board"></div>
        </div>
    </main>
</div>
<!-- Modals -->
<div id="gameOverModal" class="modal hidden">
    <h2>Game Over</h2>
    <p id="gameOverMessage"></p>
    <button id="newGameModalBtn" class="control-btn primary">Start New Game</button>
    <button id="closeModalBtn" class="control-btn">Close</button>
</div>
<div id="shareLinkModal" class="modal hidden">
    <h2>Share Your Game</h2>
    <input id="gameLinkInput" type="text" readonly>
    <button id="copyLinkModalBtn" class="control-btn">Copy Link</button>
    <button id="closeShareModalBtn" class="control-btn">Close</button>
</div>
<audio id="victoryAudio" src="https://youtu.be/92cwKCU8Z5c?si=xC1T_xWxQNJgWT0j" preload="auto"></audio>

<script>
// ---------------- ChessGame class ----------------
const PIECES = {
    WHITE: { KING:'♔', QUEEN:'♕', ROOK:'♖', BISHOP:'♗', KNIGHT:'♘', PAWN:'♙' },
    BLACK: { KING:'♚', QUEEN:'♛', ROOK:'♜', BISHOP:'♝', KNIGHT:'♞', PAWN:'♟' }
};

class ChessGame { constructor(){ this.board=this.initializeBoard(); this.currentPlayer='white'; this.selectedSquare=null; this.gameOver=false; this.moveHistory=[]; this.kings={white:{row:7,col:4},black:{row:0,col:4}}; this.castlingRights={white:{kingside:true,queenside:true},black:{kingside:true,queenside:true}}; this.enPassantTarget=null; }
initializeBoard(){ const b=Array(8).fill().map(()=>Array(8).fill(null)); b[0]=[{type:'rook',color:'black',symbol:PIECES.BLACK.ROOK},{type:'knight',color:'black',symbol:PIECES.BLACK.KNIGHT},{type:'bishop',color:'black',symbol:PIECES.BLACK.BISHOP},{type:'queen',color:'black',symbol:PIECES.BLACK.QUEEN},{type:'king',color:'black',symbol:PIECES.BLACK.KING},{type:'bishop',color:'black',symbol:PIECES.BLACK.BISHOP},{type:'knight',color:'black',symbol:PIECES.BLACK.KNIGHT},{type:'rook',color:'black',symbol:PIECES.BLACK.ROOK}]; b[1]=Array(8).fill().map(()=>({type:'pawn',color:'black',symbol:PIECES.BLACK.PAWN})); b[6]=Array(8).fill().map(()=>({type:'pawn',color:'white',symbol:PIECES.WHITE.PAWN})); b[7]=[{type:'rook',color:'white',symbol:PIECES.WHITE.ROOK},{type:'knight',color:'white',symbol:PIECES.WHITE.KNIGHT},{type:'bishop',color:'white',symbol:PIECES.WHITE.BISHOP},{type:'queen',color:'white',symbol:PIECES.WHITE.QUEEN},{type:'king',color:'white',symbol:PIECES.WHITE.KING},{type:'bishop',color:'white',symbol:PIECES.WHITE.BISHOP},{type:'knight',color:'white',symbol:PIECES.WHITE.KNIGHT},{type:'rook',color:'white',symbol:PIECES.WHITE.ROOK}]; return b;}
getPiece(r,c){return this.board[r]&&this.board[r][c];} isValidPosition(r,c){return r>=0&&r<8&&c>=0&&c<8;} isOwnPiece(r,c,color){const p=this.getPiece(r,c);return p&&p.color===color;} isEnemyPiece(r,c,color){const p=this.getPiece(r,c);return p&&p.color!==color;} 
getValidMoves(r,c){const piece=this.getPiece(r,c);if(!piece||piece.color!==this.currentPlayer)return[]; let moves=[]; switch(piece.type){case'pawn': moves=this.getPawnMoves(r,c); break; case'rook': moves=this.getRookMoves(r,c); break; case'knight': moves=this.getKnightMoves(r,c); break; case'bishop': moves=this.getBishopMoves(r,c); break; case'queen': moves=this.getQueenMoves(r,c); break; case'king': moves=this.getKingMoves(r,c); break;} return moves.filter(([tr,tc])=>!this.wouldBeInCheck(r,c,tr,tc,piece.color));}
getPawnMoves(r,c){const m=[];const p=this.getPiece(r,c);const d=p.color==='white'?-1:1; const sr=p.color==='white'?6:1; if(this.isValidPosition(r+d,c)&&!this.getPiece(r+d,c)){ m.push([r+d,c]); if(r===sr&&!this.getPiece(r+2*d,c)) m.push([r+2*d,c]);} for(const dc of [-1,1]){const nr=r+d,nc=c+dc; if(this.isValidPosition(nr,nc)){ if(this.isEnemyPiece(nr,nc,p.color)) m.push([nr,nc]); if(this.enPassantTarget&&this.enPassantTarget.row===nr&&this.enPassantTarget.col===nc)m.push([nr,nc]);}} return m;}
getRookMoves(r,c){const m=[]; const dirs=[[0,1],[0,-1],[1,0],[-1,0]]; for(const [dr,dc] of dirs){for(let i=1;i<8;i++){const nr=r+i*dr,nc=c+i*dc;if(!this.isValidPosition(nr,nc))break; const target=this.getPiece(nr,nc); if(target){ if(this.isEnemyPiece(nr,nc,this.currentPlayer)) m.push([nr,nc]); break;} m.push([nr,nc]);}} return m;}
getKnightMoves(r,c){const m=[]; const km=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]; for(const [dr,dc] of km){const nr=r+dr,nc=c+dc; if(this.isValidPosition(nr,nc)&&!this.isOwnPiece(nr,nc,this.currentPlayer)) m.push([nr,nc]);} return m;}
getBishopMoves(r,c){const m=[]; const dirs=[[1,1],[1,-1],[-1,1],[-1,-1]]; for(const [dr,dc] of dirs){for(let i=1;i<8;i++){const nr=r+i*dr,nc=c+i*dc;if(!this.isValidPosition(nr,nc))break; const target=this.getPiece(nr,nc); if(target){if(this.isEnemyPiece(nr,nc,this.currentPlayer)) m.push([nr,nc]); break;} m.push([nr,nc]);}} return m;}
getQueenMoves(r,c){return[...this.getRookMoves(r,c),...this.getBishopMoves(r,c)];}
getKingMoves(r,c){const m=[]; const dirs=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]; for(const [dr,dc] of dirs){const nr=r+dr,nc=c+dc; if(this.isValidPosition(nr,nc)&&!this.isOwnPiece(nr,nc,this.currentPlayer)) m.push([nr,nc]);} if(!this.isInCheck(this.currentPlayer)){if(this.castlingRights[this.currentPlayer].kingside&&!this.getPiece(r,c+1)&&!this.getPiece(r,c+2)&&!this.isSquareAttacked(r,c+1,this.currentPlayer)&&!this.isSquareAttacked(r,c+2,this.currentPlayer)) m.push([r,c+2]); if(this.castlingRights[this.currentPlayer].queenside&&!this.getPiece(r,c-1)&&!this.getPiece(r,c-2)&&!this.getPiece(r,c-3)&&!this.isSquareAttacked(r,c-1,this.currentPlayer)&&!this.isSquareAttacked(r,c-2,this.currentPlayer)) m.push([r,c-2]);} return m;}
isSquareAttacked(r,c,byColor){const enemy=byColor==='white'?'black':'white';for(let rr=0;rr<8;rr++){for(let cc=0;cc<8;cc++){const p=this.getPiece(rr,cc); if(p&&p.color===enemy){const moves=this.getRawMoves(rr,cc); if(moves.some(([mr,mc])=>mr===r&&mc===c)) return true;}}} return false;}
getRawMoves(r,c){const p=this.getPiece(r,c); if(!p)return[]; switch(p.type){case'pawn':return this.getPawnMoves(r,c); case'rook':return this.getRookMoves(r,c); case'knight':return this.getKnightMoves(r,c); case'bishop':return this.getBishopMoves(r,c); case'queen':return this.getQueenMoves(r,c); case'king':return this.getKingMoves(r,c);} return [];}
wouldBeInCheck(fr,fc,tr,tc,color){const temp=this.board[tr][tc]; this.board[tr][tc]=this.board[fr][fc]; this.board[fr][fc]=null; const inCheck=this.isInCheck(color); this.board[fr][fc]=this.board[tr][tc]; this.board[tr][tc]=temp; return inCheck;}
isInCheck(color){const k=this.kings[color];return this.isSquareAttacked(k.row,k.col,color);}
makeMove(fr,fc,tr,tc){const piece=this.getPiece(fr,fc); if(!piece||piece.color!==this.currentPlayer)return false; const valid=this.getValidMoves(fr,fc); if(!valid.some(([r,c])=>r===tr&&c===tc))return false; const target=this.getPiece(tr,tc); if(piece.type==='king'){this.kings[this.currentPlayer]={row:tr,col:tc}; const diff=tc-fc; if(diff===2){const rook=this.getPiece(fr,7); this.board[fr][5]=rook; this.board[fr][7]=null;} else if(diff===-2){const rook=this.getPiece(fr,0); this.board[fr][3]=rook; this.board[fr][0]=null;}} if(piece.type==='pawn'&&(tr===0||tr===7))piece.type='queen',piece.symbol=piece.color==='white'?PIECES.WHITE.QUEEN:PIECES.BLACK.QUEEN; this.board[tr][tc]=piece; this.board[fr][fc]=null; this.currentPlayer=this.currentPlayer==='white'?'black':'white'; this.moveHistory.push(`${piece.symbol} ${String.fromCharCode(97+fc)}${8-fr}-${String.fromCharCode(97+tc)}${8-tr}`); return true;}
getGameState(){return{board:this.board,currentPlayer:this.currentPlayer,moveHistory:this.moveHistory,gameOver:this.gameOver,inCheck:this.isInCheck(this.currentPlayer)?true:false};}
loadGameState(state){this.board=state.board; this.currentPlayer=state.currentPlayer; this.moveHistory=state.moveHistory; this.gameOver=state.gameOver;}
// ---------------- MultiplayerManager class ----------------
class MultiplayerManager{constructor(){this.gameId=null;this.playerColor=null;this.isHost=false;this.pollInterval=null;this.lastUpdateTime=null;}
generateGameId(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);}
createGame(){this.gameId=this.generateGameId();this.playerColor='white';this.isHost=true; const gameData={id:this.gameId,state:null,players:{white:{connected:true,name:'White Player'},black:{connected:false,name:'Black Player'}},created:Date.now()}; localStorage.setItem(`chess_game_${this.gameId}`,JSON.stringify(gameData)); return this.gameId;}
joinGame(gameId){const gameData=this.getGameData(gameId);if(!gameData)throw new Error('Game not found'); this.gameId=gameId; if(!gameData.players.white.connected)this.playerColor='white'; else if(!gameData.players.black.connected)this.playerColor='black'; else throw new Error('Game is full'); gameData.players[this.playerColor].connected=true; localStorage.setItem(`chess_game_${gameId}`,JSON.stringify(gameData)); this.startPolling(); return this.playerColor;}
getGameData(gameId){const data=localStorage.getItem(`chess_game_${gameId}`); return data?JSON.parse(data):null;}
updateGameState(gameState){if(!this.gameId)return; const gameData=this.getGameData(this.gameId); if(gameData){gameData.state=gameState;gameData.lastUpdate=Date.now(); localStorage.setItem(`chess_game_${this.gameId}`,JSON.stringify(gameData));}}
getLatestGameState(){if(!this.gameId)return null; const gameData=this.getGameData(this.gameId);return gameData?gameData.state:null;}
startPolling(){if(this.pollInterval)clearInterval(this.pollInterval); this.pollInterval=setInterval(()=>{const latestState=this.getLatestGameState(); if(latestState&&window.game){const gameData=this.getGameData(this.gameId);if(gameData&&gameData.lastUpdate&&(!this.lastUpdateTime||gameData.lastUpdate>this.lastUpdateTime)){this.lastUpdateTime=gameData.lastUpdate; window.game.loadGameState(latestState); window.updateUI();}}},1000);}
stopPolling(){if(this.pollInterval){clearInterval(this.pollInterval); this.pollInterval=null;}}
disconnectFromGame(){if(!this.gameId)return; const gameData=this.getGameData(this.gameId); if(gameData){gameData.players[this.playerColor].connected=false; localStorage.setItem(`chess_game_${this.gameId}`,JSON.stringify(gameData));} this.stopPolling(); this.gameId=null; this.playerColor=null; this.isHost=false;}
getGameLink(){if(!this.gameId)return null; return `${window.location.origin}${window.location.pathname}?game=${this.gameId}`;}
canMakeMove(){if(!this.playerColor||!window.game)return false; return window.game.currentPlayer===this.playerColor;}
getOpponentColor(){return this.playerColor==='white'?'black':'white';}
isGameFull(){if(!this.gameId)return false; const gameData=this.getGameData(this.gameId); return gameData&&gameData.players.white.connected&&gameData.players.black.connected;}}
window.MultiplayerManager=MultiplayerManager;
// ---------------- AudioManager class ----------------
class AudioManager{constructor(){this.victoryAudio=document.getElementById('victoryAudio'); this.moveSound=null; this.captureSound=null; this.checkSound=null; this.initializeSounds();}
initializeSounds(){this.audioContext=new(window.AudioContext||window.webkitAudioContext)(); if(this.victoryAudio)this.victoryAudio.volume=0.7;}
playMoveSound(){this.playTone(440,0.1,0.05);}
playCaptureSound(){this.playTone(880,0.15,0.07);}
playCheckSound(){this.playTone(1760,0.3,0.1);}
playVictorySound(){if(this.victoryAudio){this.victoryAudio.currentTime=0;this.victoryAudio.play().catch(e=>{console.warn('Could not play victory audio:',e); this.playVictoryMelody();});}else this.playVictoryMelody();}
playVictoryMelody(){const melody=[{freq:523,duration:0.2},{freq:659,duration:0.2},{freq:784,duration:0.2},{freq:1047,duration:0.4}]; let delay=0; melody.forEach(note=>{setTimeout(()=>{this.playTone(note.freq,note.duration,0.15);},delay*1000); delay+=note.duration;});}
playTone(frequency,duration,volume=0.1){if(!this.audioContext)return; const osc=this.audioContext.createOscillator(); const gain=this.audioContext.createGain(); osc.connect(gain); gain.connect(this.audioContext.destination); osc.frequency.value=frequency; osc.type='sine'; gain.gain.setValueAtTime(0,this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(volume,this.audioContext.currentTime+0.01); gain.gain.exponentialRampToValueAtTime(0.01,this.audioContext.currentTime+duration); osc.start(this.audioContext.currentTime); osc.stop(this.audioContext.currentTime+duration);}
enableAudio(){if(this.audioContext&&this.audioContext.state==='suspended')this.audioContext.resume();}}
window.AudioManager=AudioManager;
// ---------------- Main Game Script ----------------
// Global variables
let game, multiplayerManager, audioManager, boardElement, selectedSquare=null;
// DOMContentLoaded
document.addEventListener('DOMContentLoaded',()=>{initializeGame(); setupEventListeners(); const urlParams=new URLSearchParams(window.location.search); const gameId=urlParams.get('game'); if(gameId) joinExistingGame(gameId);});
function initializeGame(){game=new ChessGame(); multiplayerManager=new MultiplayerManager(); audioManager=new AudioManager(); boardElement=document.getElementById('chessBoard'); createBoard(); updateUI();}
function createBoard(){boardElement.innerHTML=''; for(let r=0;r<8;r++){for(let c=0;c<8;c++){const sq=document.createElement('div'); sq.className=`square ${(r+c)%2===0?'light':'dark'}`; sq.dataset.row=r; sq.dataset.col=c; sq.addEventListener('click',handleSquareClick); sq.addEventListener('dragover',handleDragOver); sq.addEventListener('drop',handleDrop); boardElement.appendChild(sq);}}}
function updateUI(){updateBoard(); updateGameStatus(); updateMoveHistory(); updatePlayerTurn();}
function updateBoard(){const squares=boardElement.querySelectorAll('.square'); squares.forEach(sq=>{const r=parseInt(sq.dataset.row), c=parseInt(sq.dataset.col), piece=game.getPiece(r,c); sq.innerHTML=''; sq.className=`square ${(r+c)%2===0?'light':'dark'}`; if(piece){const pe=document.createElement('div'); pe.className=`piece ${piece.color}`; pe.textContent=piece.symbol; pe.draggable=true; pe.addEventListener('dragstart',handleDragStart); sq.appendChild(pe);} if(selectedSquare&&selectedSquare.row===r&&selectedSquare.col===c)sq.classList.add('selected'); if(selectedSquare){const valid=game.getValidMoves(selectedSquare.row,selectedSquare.col); const isValid=valid.some(([rr,cc])=>rr===r&&cc===c); if(isValid){sq.classList.add('valid-move'); if(piece)sq.classList.add('occupied');}}});}
function updateGameStatus(){const el=document.getElementById('gameStatus'),state=game.getGameState(); if(state.gameOver){if(state.gameOver.type==='checkmate'){el.textContent=`Checkmate! ${state.gameOver.winner==='white'?'White':'Black'} wins!`; el.classList.add('victory-celebration'); audioManager.playVictorySound();}else if(state.gameOver.type==='stalemate') el.textContent='Stalemate! Game is a draw.';}else{el.classList.remove('victory-celebration'); let status=`${game.currentPlayer==='white'?'White':'Black'} to move`; if(state.inCheck){status+=' - Check!'; audioManager.playCheckSound();} el.textContent=status;}}
function updateMoveHistory(){const el=document.getElementById('moveHistory'),moves=game.moveHistory; if(moves.length===0){el.innerHTML='<p>No moves yet</p>'; return;} let html='<div class="moves-list">'; for(let i=0;i<moves.length;i+=2){const n=Math.floor(i/2)+1; const wm=moves[i]||'', bm=moves[i+1]||''; html+=`<div class="move-pair"><span class="move-number">${n}.</span><span class="white-move">${wm}</span><span class="black-move">${bm}</span></div>`;} html+='</div>'; el.innerHTML=html; el.scrollTop=el.scrollHeight;}
function updatePlayerTurn(){const whites=document.querySelectorAll('.white-player'), blacks=document.querySelectorAll('.black-player'); whites.forEach(p=>p.classList.remove('active')); blacks.forEach(p=>p.classList.remove('active')); if(game.currentPlayer==='white') whites.forEach(p=>p.classList.add('active')); else blacks.forEach(p=>p.classList.add('active'));}
function handleSquareClick(e){audioManager.enableAudio(); const sq=e.currentTarget, r=parseInt(sq.dataset.row), c=parseInt(sq.dataset.col); if(multiplayerManager.gameId&&!multiplayerManager.canMakeMove())return; if(selectedSquare){if(selectedSquare.row===r&&selectedSquare.col===c){clearSelection();}else{const success=attemptMove(selectedSquare.row,selectedSquare.col,r,c); if(success)clearSelection(); else{const piece=game.getPiece(r,c); if(piece&&piece.color===game.currentPlayer)selectSquare(r,c); else clearSelection();}}}else{const piece=game.getPiece(r,c); if(piece&&piece.color===game.currentPlayer)selectSquare(r,c);}}
function selectSquare(r,c){selectedSquare={row:r,col:c}; updateBoard();}
function clearSelection(){selectedSquare=null; updateBoard();}
function attemptMove(fr,fc,tr,tc){const captured=game.getPiece(tr,tc); const success=game.makeMove(fr,fc,tr,tc); if(success){if(captured)audioManager.playCaptureSound(); else audioManager.playMoveSound(); if(multiplayerManager.gameId) multiplayerManager.updateGameState(game.getGameState()); updateUI(); return true;} return false;}
// Drag and drop
function handleDragStart(e){const sq=e.target.parentElement,r=parseInt(sq.dataset.row),c=parseInt(sq.dataset.col); if(multiplayerManager.gameId&&!multiplayerManager.canMakeMove()){e.preventDefault(); return;} const piece=game.getPiece(r,c); if(piece&&piece.color===game.currentPlayer){selectSquare(r,c); e.dataTransfer.setData('text/plain',`${r},${c}`); e.target.classList.add('dragging');}else e.preventDefault();}
function handleDragOver(e){e.preventDefault();}
function handleDrop(e){e.preventDefault(); const data=e.dataTransfer.getData('text/plain'); if(!data)return; const [fr,fc]=data.split(',').map(Number); const sq=e.currentTarget; const tr=parseInt(sq.dataset.row), tc=parseInt(sq.dataset.col); document.querySelectorAll('.piece.dragging').forEach(p=>p.classList.remove('dragging')); attemptMove(fr,fc,tr,tc); clearSelection();}
// Event listeners
function setupEventListeners(){document.getElementById('newGameBtn').addEventListener('click',startNewGame); document.getElementById('shareGameBtn').addEventListener('click',shareGame); document.getElementById('copyLinkBtn').addEventListener('click',copyGameLink); document.getElementById('newGameModalBtn').addEventListener('click',startNewGame); document.getElementById('closeModalBtn').addEventListener('click',closeGameOverModal); document.getElementById('copyLinkModalBtn').addEventListener('click',copyGameLinkFromModal); document.getElementById('closeShareModalBtn').addEventListener('click',closeShareModal);}
function startNewGame(){game=new ChessGame(); selectedSquare=null; if(multiplayerManager.gameId) multiplayerManager.disconnectFromGame(); updateUI(); closeGameOverModal(); const url=new URL(window.location); url.searchParams.delete('game'); window.history.replaceState({},document.title,url);}
function shareGame(){if(!multiplayerManager.gameId){const id=multiplayerManager.createGame(); multiplayerManager.updateGameState(game.getGameState()); multiplayerManager.startPolling();} showShareModal();}
function copyGameLink(){const link=multiplayerManager.getGameLink(); if(link) navigator.clipboard.writeText(link).then(()=>alert('Game link copied to clipboard!'));}
function copyGameLinkFromModal(){const input=document.getElementById('gameLinkInput'); input.select(); document.execCommand('copy'); alert('Game link copied to clipboard!');}
function joinExistingGame(id){try{const color=multiplayerManager.joinGame(id); const state=multiplayerManager.getLatestGameState(); if(state) game.loadGameState(state); updateUI(); document.querySelector('.white-player .player-name').textContent=color==='white'?'You (White)':'Opponent (White)'; document.querySelector('.black-player .player-name').textContent=color==='black'?'You (Black)':'Opponent (Black)';}catch(e){alert(`Error joining game: ${e.message}`); const url=new URL(window.location); url.searchParams.delete('game'); window.history.replaceState({},document.title,url);}}
function showShareModal(){const modal=document.getElementById('shareLinkModal'),input=document.getElementById('gameLinkInput'); input.value=multiplayerManager.getGameLink(); modal.classList.remove('hidden');}
function closeShareModal(){document.getElementById('shareLinkModal').classList.add('hidden');}
function closeGameOverModal(){document.getElementById('gameOverModal').classList.add('hidden');}
window.game=game; window.updateUI=updateUI;
window.addEventListener('beforeunload',()=>{if(multiplayerManager) multiplayerManager.disconnectFromGame();});
</script>
</body>
</html>